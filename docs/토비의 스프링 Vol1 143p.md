# 토비의 스프링 Vol1 ~143p



## 1. Bean

스프링에서 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 Bean이라고 한다.

Bean은 IoC가 적용된 오브젝트이다.



## 2. Bean Factory

스프링에서 Bean의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 Bean Foactory라고 한다.

그렇지만 보통은 Bean Factory를 좀 더 확장한 Application Context를 사용한다.



## 3. Application Context

별도의 정보를 참고하여 Bean 의 생성, 관계설정 등의 제어 작업을 총괄한다.

평범한 자바코드 보다는 범용적인 IoC엔진같은 것이라고 보면 된다.

싱글톤방식으로 처리하고 저장해주는 싱글톤 레지스트리이다.



```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

UserDao userDao = context.getBean("userDao", UserDao.class);
```

ApplicationContext에 등록했다면 이와같은 방식으로 사용이 가능하다



장점

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
- 애플리케이션 컨텍스트는 Bean을 검색하는 다양한 방법을 제공한다



## 4. 왜 스프링은 싱글톤으로 Bean을 만드는 걸까?

스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.

스프링이 처음 설계댔던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다.

하나의 요청을 처리할때 마다 로직을 담당하는 오브젝트를 매번 만들어서 서버에 부담이 생기게 된다.

그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.

서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트로서 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 

서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.



## 5. 싱글턴의 문제점

1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
   - 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.

2. 싱글톤은 테스트하기가 힘들다.
   - 싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.

3. 서버환경에서는 싱글톤이 하나만 만들어 지는 것을 보장하지 못한다.
   - 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.
   - 여러개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.
4. 싱글톤의 사용은 전역 상태를 만들기 때문에 바람직하지 못하다.
   - 싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 어디서든 쉽게 접근할 수 있기 때문에 자연스럽게 전역상태로 사용되기 쉽다.
   - 자유롭게 접근하고 수정하고 공유할 수 있는 전역상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.



## 6. 싱글톤 레지스트리

자바의 기본적인 싱글톤 패턴의 구현방식은 여러가지 단점이 있다.

그렇기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.

이것이 바로 `싱글톤 레지스트리`이다.



스프링이 Bean을 싱글톤으로 만드는 것은 결국 오브젝트의 생성방법을 제어하는 IoC 컨테이너로서의 역할이다.

멀티스레드 환경에서 싱글톤으로 만들때는 상태정보를 내부에 가지고 있지 않는 무상태(stateless)로 만들어야 한다.



장점

- static 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.
- IoC 방식의 컨테이너를 이용하여 제이권을 넘기면 손쉽게 싱글톤으로 만들어져 관리되게 할 수 있다.
- 테스트를 위한 mock 오브젝트로 대체하는 것이 간단하다.
- 객체지향적인 설계방식과 원칙, 디자인 패턴을 적용하는데 아무런 제약이 없다.



## 7. 스프링 Bean의 scope

Bean의 scope는 일반적으로 대부분 싱글톤 scope이다.

강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.



경우에 따라서는 싱글톤 외의 scope를 가질 수 있다.

대표적으로 prototype scope가 있다. 이것은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어 준다.

외에도 request, sesstion 스코프 등도 있다.



## 8. DI(의존 관계 주입)

IoC는 매우 느슨하게 정의돼어 폭넓게 사용되고 있다.

때문에 스프링을 IoC컨테이너라고만 한다면 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

그래서 DI라는 새로운 용어가 나오게 되었다.

이는 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능이다.

그래서 지금은 DI 컨테이너라고 더 많이 불리고 있다.



의존성 주입은 다음과 같은 세가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입) 해줌으로써 만들어진다.



주입방법

- 생성자 주입
- 메서드 주입
- XML을 이용한 주입



### 8-1 XML을 이용한 설정을 사용하는 이유

범용적인 DI 컨테이너를 사용하면서 오브젝트 사이의 의존정보는 일일이 자바 코드로 만들어 주려면 번거롭다. DaoFactory를 자세히 살펴보면 알 수 있겠지만 대부분 틀에 박힌 구조가 반복된다. 또한 자바코드를 수정하고 클래스를 다시 컴파일하는 것도 귀찮은 작업이다.

스프링은 자바 클래스를 이용하는 것 외에도 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다. 가장 대표적인 것이 바로 XML이다.



### 8-2  XML 설정

DI정보가 담긴 XML 파일은 `<beans>`를 루트 엘리먼트로 사용한다.

`<beans>` 안에는 여러개의 `<bean>`을 정의할 수 있다.

@Configuration -> `<beans>`

@Bean -> `<bean>`



하나의 @Bean 메서드를 통해서 얻을 수 있는 빈의 DI 정보는 다음 세 가지다.

- 빈의 이름: @Bean 메소드 이름이 빈의 이름이다. 이 이름은 getBean()에서 사용된다.
- 빈의 클래스: 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
- 빈의 의존 오브젝트: 빈의 생성자나 수정자 메서드를 통해 의존 오브젝트를 넣어준다. 의존 오브젝트도 하나의 빈이므로 이름이 있을 것이고, 그 이름에 해당하는 메서드를 호출해서 의존 오브젝트를 가져온다. 의존 오브젝트는 하나 이상일 수도 있다.



XML에서 이 세가지 정보를 정의할 수 있다.

의존하고 있는 오브젝트가 없는 경우에는 세 번째 의존 오브젝트 정보는 생략할 수 있다.

여기서 bean의 class를 넣을때는 `패키지까지 모두 포함`해야 한다.



스프링 개발자가 setter메서드 주입을 선호하는 이유는 XML로 의존정보를 만들 때 편리하다는 점이 있다.

자바빈의 관례에 따라서 수정자 메서드는 프로터기다 된다. 프로퍼티 이름은 set을 제외한 메서드 이름을 사용한다.



`<property>` 태그는 name과 ref라는 두 개의 애트리뷰트를 갖는다.



```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
  <bean id="connectionMaker" class="springbook.user.dao.NConnectionMaker"/>

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="connectionMaker" ref="connectionMaker"/>
  </bean>

</beans>
```





```java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
```

설정 완료 후 위와 같이 사용한다.



xml 파일이 `springbook/suer/dao/daoContext.xml` 의 위치에 있다고 하자

GenericXmlApplicationContext은 클래스패스를 모두 적어야 하므로 클래스패스가 길어진다면 귀찮아진다.

 

이때 `ClassPathXmlApplicationContext("daoContext.mxl", userDao.class)` 와 같이 사용하여 상대적으로 지정할 수 있다.



## 9. DataSource

ConnectionMaker와 같은 인터페이스는 이미 추상화해서 DataSource라는 이름으로 존재한다.





## etc 애노테이션

### 1. @Configuration

Bean Factory를 위한 오브젝트 설정을 담당하는 클래스라고 인식

클래스에 @Configuration을 적용하니 final 키워드를 붙일 수 가 없었음



### 2. @Bean

오브젝트를 만들어주는 메서드에 @Bean을 붙여준다.

method에 @Bean을 적용하기 private 설정을 할 수 없었음