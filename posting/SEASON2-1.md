# 토비 뽀개기 스터디 시즌1 - 1주차

---

# 2장 테스트

---

## 스프링이 개발자에게 제공하는 가장 중요한 가치는?
* ###객체지향
* ### 테스트

   
애플리케이션은 계속 변하고 복잡해져 갑니다.   
그 변화에 대응하기 위한 두 가지 전략    

* 확장과 변화를 고려한**객체지향적 설계** 와 그것을 효과적으로 담아낼 수 있는 **IoC/DI** 같은 기술
* 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 **테스트 기술**

> #### 스프링으로 개발을 하면서 테스트를 만들지 않는다면   
> ### 이는 스프링이 지닌 가치의 절반을 포기하는 셈 입니다.

---

## 2장에서 배울것
* 테스트란 무엇인가?
* 테스트의 가치와 장점
* 테스트 활용 전략
* 테스트와 스프링과의 관계

---

## 테스트란?

내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서,   
만든 코드를 확신할 수 있게 해주는 작업입니다.   
   
테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있습니다.   
이를 통해 ```디버깅(코드의 결함을 제거) -> 테스트 성공 -> 결함 제거를 확신```

### - 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직

> 한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘듭니다.

이런 작은 단위의 코드에 대해 테스트를 수행항 것을 **단위 테스트(Unit Test)** 라고 합니다.   

여기서 말하는 ```단위란 무엇인가?, 그 크기와 범위가 어느 정도인가?``` 라는건 딱히 정해진 게 없습니다.

사용자 관리 기능을 통틀어서 하나의 단위로 볼 수도 있고,   
작게 보자면 UserDao 의 add() 메서드 하나만 가지고 하나의 단위라고 할 수 있습니다.   

> ### 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 됩니다.

#### 테스트 중 DB가 사용되면 단위 테스트라고 할 수 없을까?
매번 데이터베이스의 테이블을 비우는 등 테스트가 DB의 상태를 관장하고 있다면 이는 단위테스트 라고 해도됩니다.   

> 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 합니다.   
> 예를 들어 DB의 상태가 매번 달라지거나, 테스트를 위해 DB를 특정 상태로 만들어 줄 수 없을 때를 의미합니다.

때로는 단위 테스트 없이 바로 전 과정을 하나로 묶어서 테스트 할 필요가 있습니다.   
만약 단위 테스트 없이 긴 테스트만 존재하는 상태에서 아래와 같은 상황이 발생한다면   
* 수많은 에러가 발생해서 기능이 동작하지 않음
* 에러는 발생하지 않지만 기능은 동작하지 않음(원인을 찾기 더 힘든 상황)
* 예외가 발생하지 않고 동작은 하는데 결과가 원하는대로 나오지않음(끔찍한 상황..)

위와 같은 상황이 발생했을 때는 디버거를 돌려가며 값을 하나하나 확인해야 할 수 있습니다.   
이 때 단위 테스트가 있다면 각 단위별로 충분한 검증을 마치고 오류를 잡았기 때문에
작은 단위에서 에러가 발생해서 금방 원인을 찾아낼 수 있습니다.

> ### 단위 테스트를 하는 이유 : 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는 지를 개발자 스스로가 빨리 확인 받기 위해서 

### - 자동수행 테스트 코드
서버를 켜고 웹 화면에 폼을 띄우고 매번 User 등록 값을 개발자 스스로 입력하고 버튼을 누르는 행위로 테스트를 진행한다면   
-> 굉장히 귀찮은 작업을 반복해야 합니다.   
이를 4 ~ 5번 반복하다 보면 테스트가 귀찮아서 코드 수정(개선)을 포기하고 ```동작하니까 괜찮아```라고 생각하며 마음을 접어버릴 수 있습니다.   
   
우리가 작성했던 UserDaoTest 를 보면   
테스트 코드에 UserDao에 User 정보를 저장하고 조회하는 코드를 짜고 이를 실행하는 것으로 모든 테스트 과정이 자동으로 진행됩니다.   
이는 우리가 해야할 귀찮은 작업을 메서드 하나를 실행하는 것으로 부담없이 테스트 할 수 있습니다.

### - 지속적인 개선과 점진적인 개발을 위한 테스트
테스트가 없다면 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 그다지 미덥지 않을 수 있습니다.   
또한 마음이 불편해지면 이쯤에서 그만두자는 생각이 들 수 있습니다.   

그렇기 때문에 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고,    
테스트를 만들어 뒀기 때문에 매우 작은 단계를 거쳐가면서 테스트를 믿고 계속 코드를 개선해 나갈 수 있습니다.   

> 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라,   
> 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있습니다.

---

## UserDaoTest 의 문제점
 
### 수동 확인 작업의 번거로움
데이터의 준비는 자동으로 이뤄지고 있지만 **결과는 여전히 사람의 눈으로 확인하는 과정이 필요합니다.**  
테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수가 없습니다.   

> 이후에 검증해야할 양이 많고 복잡해지면 역시 불편함을 느낄 수 밖에 없습니다.

### 실행 작업의 번거로움
만약 DAO가 수백 개가 되고 그에 대한 main() 메서드도 그만큼 만들어진다면,   
전체 기능을 테스트해보기 위해 main() 메서드를 수백 번 실행하는 수고가 필요합니다..   
또한 수백 번 실행하면 수백 번의 결과를 직접 확인해야 합니다.

---

## 개발자가 테스트를 만들 때 자주 하는 실수

바로 성공하는 테스트만 골라서 만드는것   
개발자는 머릿속으로 이 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적입니다.   
그래서 테스트를 작성할 때도 문제가 될만한 상황이나, 입력 값 등은 교묘히도 잘 피해서 코드를 만드는 습성이 있습니다.   
   
흔히 "내 PC에서는 잘 되는데" 라는 변명이 이런 경우 입니다.   

> ### 스프링의 창시자인 로드 존슨은 "항상 네거티브 테스트를 먼저 만들라"는 조언을 했습니다.

---

## 테스트가 이끄는 개발

기능을 담당하는 코드부터 만들지 않고 해당 기능에 대한 테스트 코드부터 만드는 구체적인 개발 전략이 실제로 존재합니다.   
게다가 많은 전문적인 개발자가 이런 개발 방법을 적극적으로 사용하고 있습니다.

### 기능 설계를 위한 테스트
테스트할 코드도 없는데 어떻게 테스트를 만들 수 있을까?   
-> 추가하고 싶은 기능을 코드로 표현하려고 했기 때문에 가능   

   

이렇게 만든 테스트는 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있습니다.
이렇게 만든 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보입니다.
추가하고 싶은 기능을 일반 언어가 아니라 테스트 코드로 표현해서, 마치 코드로 설계문서 처럼 만들어놓은 것이라고 할 수 있습니다.

이렇게 했을 때 테스트가 성공한다며, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것입니다.

   

### 테스트 주도 개발(TDD, Test Driven Development)
만들고자 하는 기능의 내용을 담고 있으면서    
만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고,   
테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법입니다.   
   
TDD 는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있습니다.   
"실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."는 것이 TDD의 기본 원칙입니다.
   

### 개발자들이 테스트를 만드는 타이밍을 놓치는 이유
* 정신없이 개발하다 보면 사이사이 테스트를 만들어서 코드를 점검하는걸 놓침
* 빨리 기능을 완성하고 싶은 욕구
* 한번 집중하면 빠져드는 습성
* 코드를 만들고나서 시간이 많이 지나면 테스트를 작성하기가 막막하고 귀찮음

   

> 결국 테스트 작성은 자꾸 뒷전으로 밀려나거나 점점 더 성의 없는 테스트를 만들게 될지도 모름

    

보통 개발을 진행하면서 개발자는 계속해서 머릿속으로 예상되는 값을 생각하고 있습니다.   
코드를 살펴보다가 이런 경우는 문제가 발생하겠다는 생각이 들면 코드를 수정할 것입니다.   
-> 이것은 테스트가 실패했으니 테스트가 성공하도록 코드를 수정하는 것과 다를 바 없습니다.   
이렇게 머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 다시 반복하기가 힘듭니다.   
   

### 차라리 머릿속에서 진행하는 작업을 실제 테스트 코드로 꺼내놓으면 바로 TDD 가 됩니다.

---

## @BeforEach 와 테스트 메서드 분리

테스트 픽스쳐에 대해 @BeforeEach 를 사용할 것이냐, 메서드로 분리할 것이냐   
라는 고민을 한번쯤 한적이 있습니다.   

만약 일부 테스트에서만 공통적으로 사용되는 코드가 있다면    
@Before 를 사용하기보다는, 일반적인 메서드 추출 방법을 사용해서 메서드를 분리하고   
테스트에서 직접 호출하는 편이 낫습니다.   

단 모든 테스트에서 사용하지 않더라도, 이미 거의 모든곳에서 사용되고 있다던가, 앞으로도 사용될 여지가 보인다면   
메서드 추출보다는 @BeforEach 에 위치시켜서 모든 픽스쳐를 한곳에서 보는것이 좋습니다.   

---

## 스프링 테스트 적용

@Before 메서드는 테스트 메서드 개수만큼 반복하기 때문에 매번 애플리케이션 컨텍스트도 만들어집니다.   
지금은 설정도 간단하고 빈도 몇 개 없어서 별 문제 아닌듯 싶지만, 빈이 많아지고 복잡해지면   
그 만큼 애플리케이션 컨텍스트 생성에 적지않은 시간이 걸릴 수 있습니다.   

>애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화 하기 때문에   
단순한 오브젝트를 만드는 정도는 상관없지만    
-> 어떤 빈은 오브젝트가 생성될 때 자체적으로 초기화 작업을 진행하여 많은 시간을 필요로 할 수 있습니다.   

   

또한 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다는 점 입니다.   
이런 경우 하나의 테스트를 마칠 때 마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스를 깔끔하게 정리하지 않으면   
다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있습니다.   

   

> 또한 우리가 인수 테스트를 진행할 때 테스트 시간이 너무 길어져 버리면 이 또한 테스트 하기 싫어지는 이유가 될 수 있습니다.
> 때문에 우리는 인수테스트 만으로 끝내는것이 아닌 단위테스트도 함께 작성하여 자주 테스트 할 수 있도록 해야합니다.

   

### 해결방법
테스트는 일관성 있는 결과를 보장하기 위해 매번 새로운 오브젝트를 만들어 주는것이 원칙이지만   
애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트가 만들어지기도 합니다.   
애플리케이션 컨텍스트는 첫 초기화 후에 상태가 변하는 일은 없습니다.   
빈의 경우에는 싱글톤으로 만들었기 때문에 상태를 가지지 않도록 만듭니다.   
DB의 경우는 각 테스트가 DB의 상태를 알아서 관리할 것이므로 문제가 되지 않습니다.   

> ### 따라서 애플리케이션 컨텍스트는 상태를 가지지 않으므로 여러 테스트가 공유해서 사용해도 괜찮습니다.

이를 위해 @RunWith, @ContextConfiguration 등을 활용할 수 있습니다.
* @RunWith : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애너테이션 (JUnit4)
* @ContextConfiguration : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한것

---

## @Autowired

@Autowired 에 대한 DI 방법에 대해서는 토비의 스프링 Vol.2 에서 더욱 자세히 설명될 것이고,   
여기서는 @Autowired 가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수타입과 일치하는 컨텍스트 내의 빈을 찾습니다.   

> 타입과 일치하는 빈이 있으면 인스턴스 변수에 주입해줍니다.

---

## 인터페이스를 두고 DI 를 하는 이유

개발자는 이런 말을 할 수 있습니다. "우리는 절대로 구현 클래스를 바꾸지 않고 하나의 클래스만 사용할것이니 인터페이스 대신 직접 구현체를 생성해서 사용할 것입니다."   
   
이 말은 맞는 말 같지만 그럼에도 인터페이스를 두고 DI를 해야합니다. 그 이유는 아래와 같습니다.   

* 첫째, 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문
* 둘째, 클래스의 구현 방식은 바뀌지 않는다 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 동입할 수 있기 때문
* 세번째, 테스트를 잘 활용하려면
    - 자동으로 실행이 가능
    - 빠르게 동작
    - 가능한한 작은 단위의 대상에 국한해서 테스트
    -**DI 는 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 합니다.**
    
   
