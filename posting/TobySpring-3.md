# 토비의 스프링 3장. 템플릿

---

## 템플릿이란?

바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는것

---

## 템플릿 메서드 패턴의 적용

템플릿 메서드 패턴은 상속을 통해 기능을 확장해서 사용하는 부분입니다.

장점 - 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있습니다.

단점 - 확장 구조가 클래스를 설계하는 시점에서 고정되어 버립니다. 즉 서브 클래스들이 이미 클래스 레벨에서 컴파일 시점에 그 관계까 결정되어 있다는 것입니다.

> 단점에 의해 관계에 대한 유연성이 떨어져 버립니다.   
> 이는 상속을 통해 확장을 꾀하는 템플릿 메서드 패턴의 단점입니다.

---

## 전략 패턴

전략패턴이란 ?   
오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 것입니다.

OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식입니다.
보통 변하는 부분인 전략을 바깥에서 주입받아서 관계를 유연하게 하는 것입니다. 

---

## 의존 관계(DI)의 다양한 방법

DI의 가장 중요한 개념은 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것.   
이 개념만 따른다면 DI를 이루는 오브젝트와 구성요소의 구조나 관계는 다양하게 만들 수 있습니다.


### 일반적인 DI
* 두개의 오브젝트
* 두 오브젝트의 관계를 다이나믹(동적)하게 설정해주는 오브젝트 팩토리(DI 컨테이너)
* 오브젝트 팩토리를 사용하는 클라이언트

일반적으로 DI는 위와같은 4개의 오브젝트 사이에서 일어납니다.   

### 마이크로 DI

하지만때로는 아래와 같은 형식으로 DI가 일어납니다.
* 원시적인 전략 패턴 구조를 따라 클라이언트가 오브젝트 팩토리의 책임을 함꼐 지니고 있을 수도 있습니다.
* 클라이언트와 전략(의존 오브젝트)이 결합될 수 있습니다.
* 클라이언트와 DI 관계에 있는 두 개의 오브젝트가 모두 하나의 클래스 안에 담길 수 도 있습니다.

이런 경우 DI가 매우 작은 단위의 코드와 메서드 사이에서 일어나기도 합니다.      
얼핏 보면 DI 같아 보이지 않지만 작은 단위로 DI가 이뤄지고 있음을 홗인할 수 있습니다.   

> 이렇게 DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI 라고 부릅니다.   
> 또는 코드에 의한 DI 라는 의미로 수동 DI 라고 부를 수도 있습니다.

---
## 전략과 클라이언트의 동거

전략 패턴을 사용해서 DI 관계를 형성했지만 DAO 메서드마다 새로운 StatementStrategy를 만들어야 한다는 단점이 있습니다.   
이래서는 템플릿 메서드 패턴을 적용했을 떄 로직마다 상속받는 새로운 클래스를 만들어줘야 하는것과 큰 차이가 없습니다.   

이를 해소하기 위해 내부클래스를 활용할 수 있습니다.   

### 중첩 클래스
* 중첩 클래스(nested class) : 다른 클래스 내부에 정의되는 클래스
    * 스테틱 클래스(static class) : 독립적 오브젝트로 만들어질 수 있는 중첩 클래스
    * 내부 클래스(inner class) : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 중첩 클래스

### 내부 클래스
내부 클래스는 다시 범위(scope)에 따라 세 가지로 구분됩니다. 이는 선언된 위치에 따라 달라집니다. 
* 멤버 내부 클래스(member inner class) : 멤버 필드처럼 오브젝트 레벨에 정의 되는 내부 클래스
* 로컬 클래스(local class) :  메서드 레벨에 정의되는 내부 클래스
* 익명 내부 클래스(anonymous inner class) : 이름을 갖지않는 내부 클래스

```java
public void add(final User user) throws SQLException {
        StatementStrategy statementStrategy = new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(
                        "insert into users(id, name, password) values (?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());

                return ps;
            }
        };
        jdbcContextWithStatementStrategy(statementStrategy);
    }
```

### 익명 내부 클래스
이름을 갖지 않는 내부 클래스. 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어짐   
생성자를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 편리합니다.

```java
public void add(final User user) throws SQLException {
        jdbcContextWithStatementStrategy(
        connection -> {
        PreparedStatement ps = connection.prepareStatement(
        "insert into users(id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        return ps;
        });
        }
```

---

## 컨텍스트와 DI

위에서 사용한 구조를 전략 패턴의 구조로 보자면
* 클라이언트(Client) : UserDao 의 메서드
* 전략(Strategy) : 익명 내부 클래스로 만들어지는 것
* 컨텍스트(Context) : jdbcContextWithStatementStrategy() 메서드

jdbcContextWithStatementStrategy() 메서드는 PreparedStatement 를 실행하는 역할을 담당하고 있으니 이는 다른 DAO 에서도 사용가능하므로 클래스 밖으로 독립시켜서 다른 클래스에서도 사용가능 하도록 만드는 것이 좋습니다.

즉, 클래스 단위의 범용성을 가진다면 클래스 분리를 통해 독립시켜주는 것입니다.

### 의존관계 주입(DI)에 대한 정의
DI 의 개념에 충실히 따른다면 인터페이스를 사이에 두고 클래스 레벨에서 의존관계가 고정되지 않게 런타임에 의존할 오브젝트와의 관계를 다이나믹(동적)으로 주입해주는 것이 맞습니다.

따라서 엄밀히 말하면 인터페이스를 사용하지 않으면 온전한 DI로 볼 수 없습니다.

하지만 스프링의 DI를 넓게 본다면?   
-> 객체의 생성과 관계 설정에 대한 제어권을 외부에 위임한다는 IoC라는 개념을 포괄하기 때문에 인터페이스가 아닌 클래스를 직접 빈으로 주입해도 DI의 기본을 따른다고 볼 수 있음

즉, 스프링의 DI 관점에서 본다면 꼭 인터페이스가 아니고 클래스라도 DI의 기본을 따른다고 불 수 있다.

### 인터페이스를 사용하지않고 클래스 직접 사용해 DI를 하는 이유

1. 스프링 컨테이너의 싱글턴 레지스트리에서 관리되는 싱글턴 빈이 된다.
   서비스 오브젝트로써 싱글턴으로 등록되어 여러 오브젝트에서 공유해 사용되는 것이 이상적일때
2. 클래스가 다른 빈에게 의존하고 있을 때
   이런 경우에는 다른 빈을 DI 받기 위해서라도 스프링 빈으로 등록되어 있어야한다.
3. 강한 응집도를 가지고 있을때 
   메우 긴밀한 관계를 가지고 강하게 결합되어 함께 사용되어야 할 때를 의미합니다.

> ### 단, 클래스를 바로 사용하는 DI구조를 사용하는 것은 가장 마지막 단계에 고려해야하는 사항입니다.

### 코드를 이용하는 수동 DI

주입받고자 하는 대상에 대한 제어권을 갖고 생성과 관리를 담당하는 클래스에게 DI까지 맡기는 것   

오브젝트를 생성하고 그 의존 오브젝트를 수정자 메서드로 주입해주는 것이 바로 DI의 동작원리

#### 그렇다면 생성과 관리를 담당하는 클래스가 임시로 DI 컨테이너처럼 동작하게 하는 것

> 이 방법의 장점   
> 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 어색하게 따로 빈으로 분리하지 않고   
> 내부에서 직접 만들어 사용하면서도 다른 오브젝트에 대한 DI를 적용할 수 있다는 점

## 정리
위의 두 방법(빈으로 만들어서 DI, 코드를 활용한 수동 DI)는 각각 장단점이 있습니다.   
어떤 방법이 더 낫다고는 말할 수 없고 상황에 따라 적절하다고 판단되는 방법을 선택하되   
그 선택에 대한 분명한 이유와 근거가 있어야합니다.   

> 자신이 없다면 차라리 인터페이스를 만들어서 평범한 DI 구조로 만드는 게 나을 수 있습니다.

---

## 템플릿과 콜백

### 템플릿/콜백 패턴이란?
복잡하지만 바뀌지 않는 일정한 패턴이 반복되는 작업 흐름이 존재하고   
그 중 일부만 자주 바꿔서 사용해야 할 때   
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 스프링에서 템플릿/콜백 패턴이라고 합니다.

이전에 구현한 코드에서 전략 패턴의 컨텍스트가 템플릿, 익명 내부 클래스로 만들어지는 오브젝트를 콜백 이라고 합니다.

* 템플릿 : 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀. 프로그래밍에서는 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿이라고 부릅니다.   
  고정된 작업 흐름을 가진 코드를 재사용 한다는 의미에서 붙인 이름입니다.

> 템플릿 메서드 패턴 : 고정된 틀의 로직을 가진 템플릿 메서드를 슈퍼클래스에 두고 바뀌는 부분을 서브 클래스의 메서드에 두는 구조로 이뤄집니다.

* 콜백 : 실행되는 것을 목적으로 다른 오브젝트의 메서드에 전달되는 오브젝트를 말합니다.
  파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메서드를 실행시키기 위해 사용합니다.   
  템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 의미합니다.
  
### 템플릿 콜백의 특징

* 템플릿/콜백 패턴의 콜백은 보통 단일 메서드 인터페이스(함수형 인터페이스)를 사용합니다.   
    + 콜백은 일반적으로 하나의 메서드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 볼 수 있습니다.
* 템플릿 콜백 방식에서는 매번 메서드 단위로 사용할 오브젝트를 새롭게 전달 받습니다.
    + 일반적인 DI는 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메서드로 받아서 사용했습니다.
* 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메서드 내의 정보를 직접 참조한다는 점에서 클라이언트와 콜백이 강하게 결합되어 있습니다.

> 템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법입니다.

---

## 구체적인 클래스를 빈으로 등록하여 DI(스프링 DI 사용) vs 템플릿/콜백 구조 활용 의 장단점

### 빈으로 등록하여 DI

장점
* 빈으로 등록해서 사용하는 방법은 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다.

단점
* DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 노출된다는 단점

### 템플릿/콜백 구조 활용

장점
* 템플릿을 사용하는 클래스 내부에서 만들어지고 사용되기 때문에 그 관계를 외부에는 드러내지 않는다는 장점이 있다.
* 필요에 따라 내부에서 은밀하게 DI를 수행하고 그 전략은 외부에 감출 수 있다.

단점
* 싱글톤으로 만들 수 없음
* DI 작업을 위한 부가적인 코드가 필요하다.
 
---

## 객체 지향에서 중요한 점

변하는 것과 변하지 않는 것을 분리하고   
변하지 않는 건 유연하게 재활용할 수 있게 만든다는 간단한 원리를 계속 적용했을 때   

단순하면서도 안전하게 작성 가능한 객체지향 언어와 설계를 사용하는 매력이 나타난다.

하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들은 한 군데 모여 있는게 유리합니다.   
* 내부의 기술은 최대한 감춰두고, 외부에는 꼭 필요한 기능을 제공하는 단순한 메서드만 노출해주는 것이 좋습니다.

---

## 테스트 보완

테스트를 작성할 떄는 항상 꼼꼼하게 빠진 것은 없는지 더 개선할 부분은 없는지 한 번쯤 생각해 봐야합니다.

네거티브 테스트 : 항상 예외적인 테스트를 뺴먹지 말아야 합니다. 그러기 위해선 부정적인 자세가 필요합니다.

> QA 팀에서 하는 불만 중 하나는 개발자들이 수동 테스트를 할 때 재주 좋게도 실패할 만한 상황은 요리조리 잘 피해간다는 것

예외상황에 대한 테스트를 자꾸 뺴먹는 개발자라면 의도적으로 예외적인 조건에 대한 테스트를 먼저 만드는 습관을 들이는게 좋습니다.